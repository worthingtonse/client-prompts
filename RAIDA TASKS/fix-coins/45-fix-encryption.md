# **Function Specification: create\_fix\_encryption\_requests()**

This document specifies the create\_fix\_encryption\_requests() function. This function is responsible for creating a batch of unencrypted requests to be sent to a "fracked" RAIDA. The request contains a set of encrypted tickets obtained from helper RAIDA servers, which the fracked RAIDA can use to decrypt, assemble, and install the correct Authenticity Number (AN) for a token.

## **Core Concepts:**

* **Fracked RAIDA:** A RAIDA server with which the client's token is "fracked" (counterfeit), preventing normal encrypted communication.  
* **Encryption Ticket:** A 16-byte encrypted key part, obtained from a helper RAIDA via the "Get Encryption Ticket" command.  
* **Fracked Token:** The token whose AN needs to be fixed on the fracked RAIDA.

## **Function Signature:**

function create\_fix\_encryption\_requests(fracked\_token: {denomination: byte, serial\_number: uint32}, tickets\_to\_post: array of {helper\_raida\_id: byte, key\_id: {coin\_id: uint16, split\_id: byte, shard\_id: byte, denomination: byte, serial\_number: uint32}, encrypted\_ticket: byte\_array}, challenge\_bytes: array of 16-byte arrays): Array\<byte\[\]\> | string

* **Input Parameters:**  
  * fracked\_token (object): The token that needs to be fixed.  
    * denomination (byte)  
    * serial\_number (uint32)  
  * tickets\_to\_post (array of objects): An array where each object represents one encrypted ticket to be posted. It contains:  
    * helper\_raida\_id (byte): The ID of the RAIDA that generated this ticket.  
    * key\_id (object): The full ID of the key that the helper RAIDA used for encryption.  
      * coin\_id (uint16)  
      * split\_id (byte)  
      * shard\_id (byte)  
      * denomination (byte)  
      * serial\_number (uint32)  
    * encrypted\_ticket (16-byte array): The ticket received from the helper RAIDA.  
  * challenge\_bytes (array of 16-byte arrays): An array of 25 unique 16-byte challenges.  
* **Return Value:**  
  * An array of 25 complete, prepared, and unencrypted byte arrays. Each byte array represents a full request. The client will send the appropriate request to the target fracked RAIDA.  
  * Returns the string "failure" if any significant, unrecoverable error occurs.

## **Request Structure Overview:**

Each request consists of three main parts, concatenated in order:

1. **Request Header (32 bytes):** Contains metadata, including the target server ID and the command.  
2. **Request Body (variable length):** Contains the challenge, the ID of the fracked token, and the list of tickets to post.  
3. **Termination Bytes (2 bytes):** A fixed sequence (0x3E 0x3E) to mark the end of the request.

## **Detailed Logic:**

The function will construct 25 distinct requests, one for each potential RAIDA server (Server ID 0 to 24). The body of the request will be identical for all 25\.

### **1\. Request Body Construction (variable length):**

* Let N be the number of tickets in the tickets\_to\_post array.  
* The size of the data for one ticket is 1 (helper\_id) \+ 9 (key\_id) \+ 16 (ticket) \= 26 bytes.  
* The total body length will be 16 (challenge) \+ 5 (fracked\_token\_id) \+ (N \* 26\) bytes.  
* The body is constructed by concatenating the following parts in order:  
  * **Challenge (16 bytes):** The corresponding 16-byte challenge from the challenge\_bytes input array.  
  * **Fracked Token ID (5 bytes):** The 1-byte denomination and 4-byte serial\_number from the fracked\_token parameter.  
  * **Tickets to Post (N \* 26 bytes):** For each item in the tickets\_to\_post array, append:  
    * helper\_raida\_id (1 byte)  
    * key\_id.coin\_id (2 bytes)  
    * key\_id.split\_id (1 byte)  
    * key\_id.shard\_id (1 byte)  
    * key\_id.denomination (1 byte)  
    * key\_id.serial\_number (4 bytes)  
    * encrypted\_ticket (16 bytes)

### **2\. Request Header Construction (32 bytes):**

Create a 32-byte header for each of the 25 servers. This function uses **Encryption Type 0 (No Encryption)**.

* **Bytes 0-3:**  
  * Byte 0 (VR): 0x00  
  * Byte 1 (SP): 0x00  
  * Byte 2 (RI): **Server ID** (from 0x00 for server 0, up to 0x18 for server 24\)  
  * Byte 3 (SH): 0x00  
* **Bytes 4-5 (Command):**  
  * Byte 4 (CG): 0x04 (Command Group: Healing Services For Keys)  
  * Byte 5 (CM): 0x2D (Command: Fix Encryption, which is 45 in decimal)  
* **Bytes 6-15:** All set to 0x00.  
* **Byte 16 (EN):** 0x00 (Encryption Type: No Encryption).  
* **Bytes 17-21:** All set to 0x00.  
* **Bytes 22-23 (BL):** The length of the body plus two termination bytes. This will be (21 \+ (N \* 26)) \+ 2 \= 23 \+ (N \* 26). This value is represented as a 16-bit unsigned integer (big-endian).  
* **Bytes 24-29:** All set to 0x00.  
* **Bytes 30-31 (Echo):** Two randomly generated bytes.

### **3\. Termination Bytes:**

* After the header and body, append two fixed termination bytes: 0x3E 0x3E.

### **4\. Final Request Assembly:**

* For each of the 25 servers, concatenate the constructed Header, the shared Body, and the Termination Bytes into a single byte array.  
* Return the array containing all 25 complete request byte arrays.

## **Logging and Error Handling:**

* **Success:** Log key milestones, such as the start of the function and its successful completion.  
* **Errors:** Log any errors encountered during the process (e.g., invalid input parameters). Any error that prevents the successful creation of all 25 requests should cause the function to log the error and return the string "failure".
